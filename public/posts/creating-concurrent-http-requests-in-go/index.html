<!DOCTYPE html>
<html lang="en">

    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><title>Creating Concurrent HTTP Requests in Go &ndash; tribuana.dev</title>
<meta name="description" content="Software engineer">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8"/>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css" integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />


<link rel="stylesheet" href="http://localhost:1313/css/palettes/base16-dark.css">
<link rel="stylesheet" href="http://localhost:1313/css/risotto.css">
<link rel="stylesheet" href="http://localhost:1313/css/custom.css">


<link rel="icon" href="http://localhost:1313/favicon.ico">




</head>

    <body>
        <div class="page">

            <header class="page__header"><nav class="page__nav main-nav">
    <ul>
    <h1 class="page__logo"><a href="http://localhost:1313/" class="page__logo-inner">tribuana.dev</a></h1>
    
    
    <li class="main-nav__item"><a class="nav-main-item active" href="http://localhost:1313/posts/" title="Posts">/Posts</a></li>
    
    <li class="main-nav__item"><a class="nav-main-item" href="/tags" title="tags">/tags</a></li>
    </ul>
</nav>

</header>

            <section class="page__body">
    <header class="content__header">
        <h1>Creating Concurrent HTTP Requests in Go</h1>
    </header>
    <div class="content__body">
        <p>A while ago I&rsquo;ve had the pleasure of having to hit a particularly slow third party API multiple times in a single request. The amount of requests sent is variable and so the time taken by this single request can be arbitrarily slow, as shown in the graphics below.</p>
<p><img src="linear.png" alt="A linear sequence"></p>
<p>Obviously this can get out of control quick. As I was writing in Go, I immediately went to the universal hammer of all Go code: Goroutines. Ideally, the timeline should look more like this:</p>
<p><img src="concurrent.png" alt="Concurrent sequence"></p>
<p>This way, even the biggest request will only be as slow as its slowest API response + some overhead from coroutines.</p>
<h2 id="first-step---the-humble-waitgroup">First Step - The Humble Waitgroup</h2>
<p>At first I wrote the most basic goroutine usage with waitgroup.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">payloads</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sendRequest</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span></code></pre></div><p>The scope of sendRequest is beyond this post. However, it is just a standard HTTP client request based on the payload value. I trust most people reading this post would already be familiar with how to do that, or at least the general idea of it.</p>
<p>Clearly, this is far from enough. For one, I&rsquo;m not capturing the response. Second, I am not handling any errors. Let&rsquo;s tackle them one by one.</p>
<h2 id="second-step---channel-for-my-answers">Second Step - Channel for My Answers</h2>
<p>I figured that since all of the requests may finish at different times, I should probably set up a channel to accept them one by one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resCh</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Response</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">payloads</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sendRequest</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resCh</span>)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    close(<span style="color:#a6e22e">resCh</span>)
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">resCh</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Inside of sendRequest</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendRequest</span>(<span style="color:#a6e22e">payload</span> <span style="color:#a6e22e">Payload</span>, <span style="color:#a6e22e">resCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Response</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#a6e22e">Response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resCh</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we&rsquo;re getting somewhere. The payload loop would spawn producer threads that send their results down the channel. In the main thread, another consumer thread is spawned to wait on the waitgroup, and then close the channel.</p>
<p>If you&rsquo;re unfamiliar with how Go handles channels, the following code will block the thread forever until the channel is closed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">resCh</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Due to that, when we have no idea how many channels will be coming in, we have to spawn a consumer thread that will wait on all waitgroups and manually close the channel to allow the main thread to continue.</p>
<p>Notice also how I explicitly declare the <code>resCh</code> inside of <code>sendRequest</code> parameter as a receive only channel.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendRequest</span>(<span style="color:#a6e22e">payload</span> <span style="color:#a6e22e">Payload</span>, <span style="color:#a6e22e">resCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Response</span>)
</span></span></code></pre></div><p>For this case, it is not that necessary, but being explicit about how a function will use a channel can prevent massive headache down the line, such as a function that unexpectedly consumes a channel instead of producing, leading to starvation in the main thread.</p>
<h2 id="third-step---error-handling-my-beloved">Third Step - Error Handling, My Beloved</h2>
<p>Now we have our HTTP requests firing and their responses ready to be used. A bad programmer would call it a day here and open a PR. However, in Go, we love our <code>if err != nil</code> checks. So, we should add some error handling to our code.</p>
<p>The question is, how? The first kneejerk reaction would be to create an error channel that the <code>sendRequest</code> function can push an error value to. However, this can get real messy and confusing. A more elegant solution would be to use <a href="https://pkg.go.dev/golang.org/x/sync/errgroup">errgroup</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">errGroup</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errgroup</span>.<span style="color:#a6e22e">WithContext</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>())
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resCh</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">Response</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">payloads</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">errGroup</span>.<span style="color:#a6e22e">Go</span>(<span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sendRequest</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">resCh</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">errGroup</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    close(<span style="color:#a6e22e">resCh</span>)
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errGroup</span>.<span style="color:#a6e22e">Wait</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">resCh</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something</span>
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Inside of sendRequest</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendRequest</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">payload</span> <span style="color:#a6e22e">Payload</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">resCh</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">Response</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#a6e22e">Response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">NewRequestWithContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">METHOD</span>, <span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">DATA</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">resCh</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">result</span>: <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>(): <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Err</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That&rsquo;s quite a lot, so let&rsquo;s go through it one by one.</p>
<p>First, notice how we&rsquo;ve ditched waitgroup for errgroup. You can think of errgroup as a more convenient version of waitgroup. Instead of spawning a goroutine and then doing the classic</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span></code></pre></div><p>Errgroup instead got a <code>.Go</code> method that would spawn a thread of the given closure function. Errgroup also has the <code>.Wait</code> method which would block a thread until all spawned errgroup has closed. The special thing about this method is that it also yields an <code>error</code> value based on the return of the closure functions given to <code>.Go</code>.</p>
<p>Some of you might be wondering, &ldquo;hey, why&rsquo;s <code>.Wait</code> being called twice here?&rdquo;. The answer to that is that the <code>.Wait</code> inside of the <code>go func</code> is your usual consumer thread. It will wait until all errgroup is done, and then close the channel. Nothing special here.</p>
<p>The <code>.Wait</code> on the main thread, however, will block the thread until the errgroup is done. This ensures that no requests are dropped before the program continues to process the responses.</p>
<p><img src="errgroup.png" alt="errgroup flow"></p>
<h2 id="conclusion">Conclusion</h2>
<p>And so, our little concurrent HTTP request handler is done. Some people think that Goroutines and channels are the confusing part of Go language. Personally, I find them to be intuitive and way easier than rawdogging <code>pthreads</code> in C. Much less confusing than web workers too, but maybe that&rsquo;s just due to my inexperience with it.</p>

    </div>
    <footer class="content__footer"></footer>

            </section>

            <section class="page__aside">
                <div class="aside__about">
<div class="aside__about">
    
<h1 class="about__title">Yudhistira Tribuana</h1>
<p class="about__description">Software engineer</p>
</div>


<ul class="aside__social-links">
    
    <li>
        <a href="https://github.com/YudhistiraTA" rel="me" aria-label="GitHub" title="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>&nbsp;
    </li>
    
    <li>
        <a href="mailto:yudhistira@tribuana.dev" rel="me" aria-label="Email" title="Email"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a>&nbsp;
    </li>
    
</ul>
</div>
                <hr>
                <div class="aside__content">
    
    
        <p>
            
            2025-08-03
             
<ul>
   <li>
    <a href="http://localhost:1313/tags/programming/">programming</a>
  </li></ul>

        </p>
    

    

                </div>
            </section>

            <footer class="page__footer"><p>
    
    
    
    
    
    
      
    
    
</p>
<br /><br />
<p class="copyright"></p>
</footer>

        </div>
    </body>

</html>
